I"Œ<p><a href="http://dev.stephendiehl.com/fun/002_parsers.html">http://dev.stephendiehl.com/fun/002_parsers.html</a></p>

<p><a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing">https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing</a></p>

<p><a href="http://book.realworldhaskell.org/read/using-parsec.html">http://book.realworldhaskell.org/read/using-parsec.html</a></p>

<blockquote>
  <p>import Control.Applicative hiding (many)
import Control.Monad (liftM, ap)
import Control.Monad.Plus
Iâ€™m going based on <a href="http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf">http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf</a> A paper on monadic parsing by Hutton. More than based. Iâ€™m copying code.
Iâ€™m just writing down what I think as Iâ€™m going through this paper.
So what is going on here.
A parser is a little guy that will try to pull off all it can that patches from a string. If it canâ€™t find anything
it will return an empty list. If it can match more than one option, itâ€™ll return a list of possibilities</p>
</blockquote>

<p>It feels more like a little regular expression guy
Its kind of a combo of a state monad and the list monad.
The state is the current string that is left to be chewed up
the list monad is for nondeterminstic computation, it returns all possible results
One wonders if this could be constructed useful using monad transformers
Donâ€™t know much aout those but that is how the feel. For composing multiple monads.</p>
<blockquote>
  <p>newtype Parser a = Parser (String -&gt; [(a,String)])
parse (Parser x) = x</p>
</blockquote>

<p>Now, why is the type a function? What is going to happen is weâ€™re going to define a way to compose these little
functions in a way to build up the big parser from the little ones. The a type parameter is interesting.
Maybe it returns a token representing what it found. Or maybe it just returns the string that matches</p>

<blockquote>
  <p>item :: Parser Char
item = Parser (\cs -&gt; case cs of
â€œâ€ -&gt; []
(c:cs) -&gt; [(c,cs)])</p>
</blockquote>

<p>So item produces a parser that will match any character.</p>

<p>How do we grab all items? Well we need to compose up a bunch of these item guys.
What we kind of want is something that feels like
item3 = item $ item $ item
This doesnâ€™t work because the types in and out downâ€™t match. So it needs to be a monad to replace function application $ with
the monaidc bindÂ Â»=</p>

<blockquote>
  <p>instance Monad Parser where
return a = Parser (\cs -&gt; [(a,cs)])
pÂ Â»= f = Parser (\cs -&gt; concat [parse (f a) csâ€™ |
(a,csâ€™) &lt;- parse p cs])</p>
</blockquote>

<p>return makes a trivial parser: A function that doesnâ€™t change the string at all and returns the object a no matter what the string said.
The bind operation composes the operations. What does it need to do?</p>
<ol>
  <li>It needs to return a function String -&gt; [(a,String)] wrapper in a Parser constructor</li>
  <li>It needs to strip the left over string coming out of pâ€™s function and pass it into the function f makes</li>
  <li>f might need to know what came before it to decide what parser to makes?</li>
  <li>For every possibility that comes out of p you need to try what comes out of (f a)</li>
</ol>

<p>I think 4 is non obvious. Weâ€™ll see if I change my mind.</p>

<p>So he used a list comprehension. Not what I wouldâ€™ve thought of. Itâ€™s clean though. Hereâ€™s a very shitty construction process</p>

<p>Needs to return a function from strings
pÂ Â»= f = Parser (\cs
Need to use (parse p) to start. Then we have that list [(a,csâ€™)]
pÂ Â»= f = Parser (\cs -&gt; (parse p) cs )
Probably map over the list we need to do something for every element
pÂ Â»= f = Parser (\cs -&gt; map (parse p) cs )
What are we applying? f I guess. We need to apply f the the first argument to make a parser. Now we have a list of parsers.
pÂ Â»= f = Parser (\cs -&gt; map (f . fst) (parse p) cs )
Now get those functions out
pÂ Â»= f = Parser (\cs -&gt; map parse (map (f . fst) (parse p) cs))
This is getting too long. Things are getting out of hand. So I define intermediate expressions.
Now apply them
pÂ Â»= f = Parser (\cs -&gt; map fs (map snd acs)
where
acs = (parse p) cs
fs = map parse (map (f . fst) acs)</p>

<p>eh screw it</p>

<p>The list monad has a similar bind.
God Do I have to implement Functor too? Probably.</p>

<blockquote>
  <p>instance Functor Parser where
fmap = liftM</p>
</blockquote>

<blockquote>
  <p>instance Applicative Parser where
pure = return
(&lt;*&gt;) = ap</p>
</blockquote>

<p>Monad is automatically a functor and applicatibe. I should look up the defintions of those functions</p>
<blockquote>
  <p>p :: Parser (Char,Char)
p = do {c &lt;- item; item; d &lt;- item; return (c,d)}</p>
</blockquote>

<p>ghci returns
*Main&gt; (parse p) â€œqwertyâ€
[((â€˜qâ€™,â€™eâ€™),â€rtyâ€)]</p>

<p>So to add parsers allows you to take different routes.
The zero parser does jack all</p>

<blockquote>
  <p>instance MonadPlus Parser where
mzero = Parser (\cs -&gt; [])
mplus f g = Parser (\cs -&gt; (parse f) cs ++ (parse g) cs)</p>
</blockquote>

<blockquote>
  <p>instance Alternative Parser where
(&lt;|&gt;) = mplus
empty = mzero
sat :: (Char -&gt; Bool) -&gt; Parser Char
sat p = do c &lt;- item
if (p c) then (return c) else mzero</p>
</blockquote>

<blockquote>
  <p>findq = sat (== â€˜qâ€™)</p>
</blockquote>

<p>*Main&gt; parse findq â€œqwerrâ€
[(â€˜qâ€™,â€werrâ€)]
*Main&gt; parse findq â€œwerrâ€
[]</p>

<blockquote>
  <p>char :: Char -&gt; Parser Char
char c = sat (c ==)</p>
</blockquote>

<blockquote>
  <p>string :: String -&gt; Parser String
string â€œâ€ = return â€œâ€
string (c:cs) = do char c
string cs
return (c:cs)
many :: Parser a -&gt; Parser [a]
many p = many1 p <code class="language-plaintext highlighter-rouge">mplus</code> (return [])
many1 :: Parser a -&gt; Parser [a]
many1 p = do a &lt;- p
as &lt;- many p
return (a:as)</p>
</blockquote>

<p>*Main&gt; parse (many (char â€˜câ€™)) â€œyoyoyocâ€
[(â€œâ€,â€yoyoyocâ€)]
*Main&gt; parse (many (char â€˜câ€™)) â€œccyoyoyocâ€
[(â€œccâ€,â€yoyoyocâ€),(â€œcâ€,â€cyoyoyocâ€),(â€œâ€,â€ccyoyoyocâ€)]</p>
<blockquote>
  <p>isSpace s = s == â€˜ â€˜ || s == â€˜\tâ€™ || s == â€˜\nâ€™ || s == â€˜\râ€™
space :: Parser String
space = many (sat isSpace)</p>
</blockquote>

<blockquote>
  <p>token :: Parser a -&gt; Parser a
token p = do {a &lt;- p; space; return a}</p>
</blockquote>

<blockquote>
  <p>symb :: String -&gt; Parser String
symb cs = token (string cs)</p>
</blockquote>

<blockquote>
  <p>apply :: Parser a -&gt; String -&gt; [(a,String)]
apply p = parse (do {space; p})</p>
</blockquote>

<blockquote>
  <p>data Expr = Expr Addop Term | Term
data Term = Val Int</p>
</blockquote>

<p>and Iâ€™m tired So Iâ€™ll stop.</p>
:ET
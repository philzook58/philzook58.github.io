I"ƒ<p>Iâ€™ve found looking at my statistics that short, to the point, no bull crap posts are the most read and probably most useful.</p>

<p>Iâ€™ve been tinkering around with typed template Haskell, which a cursory internet search doesnâ€™t make obvious even exists. The first thing to come up is a GHC implementation wiki that seems like it might be stalled in some development branch. No. Typed template Haskell is already in GHC since GHC 7.8. And the first thing that comes up on a template haskell google search is the style of Template Haskell where you get deep into the guts of the syntax tree, which is much less fun.</p>

<p>Hereâ€™s a basic addition interpreter example.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
{-# LANGUAGE TemplateHaskell -#}
import Language.Haskell.TH
import Language.Haskell.TH.Syntax

data Expr = Val Int | Add Expr Expr

eval' :: Expr -&gt; Int
eval' (Val n) = n
eval' (Add e1 e2) = (eval' e1) + (eval' e2)

eval :: Expr -&gt; TExpQ Int
eval (Val n) = [|| n ||]
eval (Add e1 e2) = [|| $$(eval e1) + $$(eval e2) ||]


</code></pre></div></div>

<p>The typed splice <code class="language-plaintext highlighter-rouge">$$</code> takes <code class="language-plaintext highlighter-rouge">a</code> out of <code class="language-plaintext highlighter-rouge">TExpQ a</code>. The typed quote <code class="language-plaintext highlighter-rouge">[|| ||]</code> puts it in. I find that you tend to be able to follow the types to figure out what goes where. If youâ€™re returning a TExpQ, you probably need to start a quote. If you need to recurse, you often need to splice. Etc.</p>

<p>You tend to have to put the actual use of the splice in a different file. GHC will complain otherwise.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
ex1 :: Int
ex1 = $$(eval (Add (Val 1) (Val 1)))
</code></pre></div></div>

<p>At the top of your file put this to have the template haskell splices dumped into a file</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
{-# OPTIONS_GHC -ddump-splices -ddump-to-file #-}
</code></pre></div></div>

<p>Or have your package.yaml look something like this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
executables:
  staged-exe:
    main:                Main.hs
    source-dirs:         app
    ghc-options:
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    - -ddump-splices
    - -ddump-to-file
    dependencies:
    - staged
</code></pre></div></div>

<p>If youâ€™re using stack, you need to dive into .stack/dist/x86/Cabal/build and then /src or into the executable folder something-exe-tmp/app to find .dump-splices files.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
app/Main.hs:11:10-35: Splicing expression
    eval (Add (Val 1) (Val 1)) ======&gt; (1 + 1)
</code></pre></div></div>

<p>Nice. I donâ€™t know whether GHC might have optimized this thing down anyhow or not, but we have helped the process along.</p>

<p>Some more examples: unrolling the recursion on a power function (a classic)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
-- ordinary version
power 0 x = 1
power n x = x * (power (n-1) x)

-- templated up
power' :: Int -&gt; TExpQ (Int -&gt; Int)
power' 0 = [|| const 1 ||]
power' n = [|| \x -&gt; x * $$(power' (n-1)) x ||] 
</code></pre></div></div>

<p>You can unroll a fibonacci calculation</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
-- unrolled fib woth sharing
fib 0 = 1
fib 1 = 1
fib n = (fib (n-1)) + (fib (n-2))

-- we always need [||  ||] wheneve there is a Code
fib' :: Int -&gt; TExpQ Int
fib' 0 = [|| 1 ||]
fib' 1 = [|| 1 ||] 
fib' n = [|| $$(fib' (n-1)) + $$(fib' (n-2)) ||]
</code></pre></div></div>

<p>This is blowing up in calculation though (no memoization, you silly head).  We can implement sharing in the code using let expression (adapted from <a href="https://wiki.haskell.org/The_Fibonacci_sequence">https://wiki.haskell.org/The_Fibonacci_sequence</a>). Something to think about.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
fib4 :: Int -&gt; TExpQ Int
fib4 n = go n [|| ( 0, 1 ) ||]
                where
                  go :: Int -&gt; TExpQ (Int, Int) -&gt; TExpQ Int
                  go n z | n==0      = [|| let (a,b) = $$(z) in a ||]
                         | otherwise = go (n-1) [|| let (a,b) = $$(z) in (b, a + b) ||]
</code></pre></div></div>

<p>Tinkering around, youâ€™ll occasionally find GHC canâ€™t splice and quote certain things. This is related to cross stage persistence and lifting, which are confusing to me. You should look in the links below for more info.  I hope Iâ€™ll eventually get a feel for it.</p>

<p>If you want to see more of my fiddling in context to figure out how to get stuff to compile hereâ€™s my github that Iâ€™m playing around in  <a href="https://github.com/philzook58/staged-fun">https://github.com/philzook58/staged-fun</a></p>

<p>Useful Link Dump:</p>

<p>Simon Peyton Jones has a very useful talk slides. Extremely useful  <a href="https://www.cl.cam.ac.uk/events/metaprog2016/Template-Haskell-Aug16.pptx">https://www.cl.cam.ac.uk/events/metaprog2016/Template-Haskell-Aug16.pptx</a></p>

<p>Matthew Pickeringâ€™s post keyed me into that Typed Template Haskell is even there.</p>

<p><a href="http://mpickering.github.io/posts/2019-02-14-stage-3.html"> http://mpickering.github.io/posts/2019-02-14-stage-3.html</a></p>

<p><a href="https://www.youtube.com/watch?v=AzJVFkm42zM">MuniHac 2018: Keynote: Beautiful Template Haskell</a></p>

<p><a href="https://markkarpov.com/tutorial/th.html">https://markkarpov.com/tutorial/th.html</a> Mark Karpov has a useful Template Haskell tutorial</p>

<p>Oleg Kiselyov: Iâ€™m still trying to unpack the many things that are going on here. Olegâ€™s site and papers are a very rich resource.</p>

<p>I donâ€™t think that staged metaprogramming requires finally tagless style, as I first thought upon reading some of his articles. It is just very useful.</p>

<p><a href="http://okmij.org/ftp/meta-programming/">http://okmij.org/ftp/meta-programming/</a></p>

<p><a href="http://okmij.org/ftp/meta-programming/tutorial/">http://okmij.org/ftp/meta-programming/tutorial/</a></p>

<p>Typed Template Haskell is still unsound (at least with the full power of the Q templating monad) <a href="http://okmij.org/ftp/meta-programming/#TExp-problem">http://okmij.org/ftp/meta-programming/#TExp-problem</a></p>

<p>You can write things in a finally tagless style such that you can write it once and have it interpreted as staged or in other ways. There is a way to also have a subclass of effects (Applicatives basically?) less powerful than Q that is sound.</p>

:ET
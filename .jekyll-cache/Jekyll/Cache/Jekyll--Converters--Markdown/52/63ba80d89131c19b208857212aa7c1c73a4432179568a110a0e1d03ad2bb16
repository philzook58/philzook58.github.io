I"ˆM<p>Quantum computing exploits the massive vector spaces nature uses to describe quantum phenomenon.</p>

<p>The evolution of a quantum system is described by the application of matrices on a vector describing the quantum state of the system. The vector has one entry for every possible state of the system, so the number of entries can get very, very large. Every time you add a new degree of freedom to a system, the size of the total state space gets <em>multiplied</em> by the size of the new DOF, so you have a vector exponentially sized in the¬† number¬† of degrees of freedom.</p>

<p>Now, a couple caveats. We could have described probabilistic dynamics similarly, with a probability associated with each state. The subtle difference is that quantum amplitudes are complex numbers whereas probabilities are positive real numbers. This allows for interference. Another caveat is that when you perform a measurement, you only get a single state, so you are hamstrung by the tiny amount of information you can actually extract out of this huge vector. Nevertheless, there are a handful of situations where, to everyone‚Äôs best guess, you get a genuine quantum advantage over classical or probabilistic computation.</p>

<p>Topological quantum computing is based around the braiding of particles called anyons. These particles have a peculiar vector space associated with them and the braiding applies a matrix to this space. In fact, the space associated with the particles can basically only be manipulated by braiding and other states require more energy or very large scale perturbations to access. Computing using anyons has a robustness compared to a traditional quantum computing systems. It can be made extremely unlikely that unwanted states are accessed or unwanted gates applied. The physical nature of the topological quantum system has an intrinsic error correcting power. This situation is schematically similar in some ways to classical error correction on a magnetic hard disk. Suppose some cosmic ray comes down and flips a spin in your hard disk. The physics of magnets makes the spin tend to realign with it‚Äôs neighbors, so the physics supplies an intrinsic classical error correction in this case.</p>

<p>The typical descriptions of how the vector spaces associated with anyons work I have found rather confusing. What we‚Äôre going to do is implement these vector spaces in the functional programming language Haskell for concreteness and play around with them a bit.</p>

<h6 id="anyons">Anyons</h6>

<p>In many systems, the splitting and joining of particles obey rules. Charge has to be conserved. In chemistry, the total number of each individual atom on each side of a reaction must be the same. Or in particle accelerators, lepton number and other junk has to be conserved.</p>

<p>Anyonic particles have their own system of combination rules. Particle A can combine with B to make C or D. Particle B combined with C always make A. That kind of stuff. These rules are called fusion rules and there are many choices, although they are not arbitrary. They can be described by a table $latex N_{ab}^{c}$ that holds counts of the ways to combine a and b into c. This table has to be consistent with some algebraic conditions, the hexagon and pentagon equations, which we‚Äôll get to later.</p>

<p>We need to describe particle production trees following these rules in order to describe the anyon vector space.</p>

<p>Fibonacci anyons are one of the simplest anyon systems, and yet sufficiently complicated to support universal quantum computation. There are only two particles types in the Fibonacci system, the $latex I$ particle and the $latex \tau$¬† particle. The $latex I$ particle is an identity particle (kind of like an electrically neutral particle). It combines with $latex \tau$ to make a $latex \tau$. However, two $latex \tau$ particle can combine in two different ways, to make another $latex \tau$ particle or to make an $latex I$ particle.</p>

<p>So we make a datatype for the tree structure that has one constructor for each possible particle split and one constructor (TLeaf, ILeaf) for each final particle type.¬†We can use¬†GADTs (Generalize Algebraic Data Types) to make only good particle production history trees constructible. The type has two type parameters carried along with it, the particle at the root of the tree and the leaf-labelled tree structure, represented with nested tuples.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data Tau
data Id
data FibTree root leaves where
   TTT :: FibTree Tau l -&gt; FibTree Tau r -&gt; FibTree Tau (l,r)
   ITT :: FibTree Tau l -&gt; FibTree Tau r -&gt; FibTree Id (l,r) 
   TIT :: FibTree Id l -&gt; FibTree Tau r -&gt; FibTree Tau (l,r)
   TTI :: FibTree Tau l -&gt; FibTree Id r -&gt; FibTree Tau (l,r)
   III :: FibTree Id l -&gt; FibTree Id r -&gt; FibTree Id (l,r)
   TLeaf :: FibTree Tau Tau
   ILeaf :: FibTree Id Id
</code></pre></div></div>

<h6 id="free-vector-spaces">Free Vector Spaces</h6>

<p>We need to describe quantum superpositions of these anyon trees. We‚Äôll consider the particles at the leaves of the tree to be the set of particles that you have at the current moment in a time. This is a classical quantity. You will not have a superposition of these leaf particles. However, there are some quantum remnants of the history of how these particles were made. The exact history can never be determined, kind of like how the exact history of a particle going through a double slit cannot be determined. However, there is still a quantum interference effect left over. When you bring particles together to combine them, depending on the quantum connections, you can have different possible resulting particles left over with different probabilities. Recombining anyons and seeing what results is a measurement of the system .</p>

<p>Vectors can be described in different basis sets. The bases for anyon trees are labelled by both a tree structure and what particles are at the root and leaves.¬†Different tree associations are the analog of using some basis x vs some other rotated basis x‚Äô.¬†The way we‚Äôve built the type level tags in the FibTree reflects this perspective.</p>

<p><a href="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/243b7117-10e3-4211-866c-718ef9eabea9-1.png"><img src="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/243b7117-10e3-4211-866c-718ef9eabea9-1.png" alt="" /></a></p>

<p>The labelling of inner edges of the tree with particles varies depending on which basis vector we‚Äôre talking about. A different inner particle is the analog of $latex \hat{x}$ vs $latex \hat{y}$.<a href="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/243b7117-10e3-4211-866c-718ef9eabea9-2.png"><img src="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/243b7117-10e3-4211-866c-718ef9eabea9-2.png" alt="" /></a></p>

<p>To work with these bases we need to break out of the mindset that a vector put on a computer is the same as an array. While for big iron purposes this is close to true, there are more flexible options.¬†The array style forces you to use integers to index your space, but what if your basis does not very naturally map to integers?</p>

<p>A free vector space over some objects is the linear combination of those objects. This doesn‚Äôt have the make any sense. We can form the formal sum (3.7üíã+2.3iüë©‚Äçüé®) over the emoji basis for example. Until we attach more meaning to it, all it really means is a mapping between emojis and numerical coefficients. We‚Äôre also implying by the word vector that we can add two of the combinations coefficient wise and multiply scalars onto them.</p>

<p>We are going to import free vectors as described by the legendary Dan Piponi as described here:<a href="http://blog.sigfpe.com/2007/03/monads-vector-spaces-and-quantum.html"> http://blog.sigfpe.com/2007/03/monads-vector-spaces-and-quantum.html</a></p>

<p>What he does is implement the Free vector space pretty directly. We represent a Vector space using a list of tuples [(a,b)]. The a are basis objects and b are the coefficients attached to them.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data W b a = W { runW :: [(a,b)] } deriving (Eq,Show,Ord)
instance Semigroup (W b a) where
  (W x) &lt;&gt; (W y) = W (x &lt;&gt; y)
instance Monoid (W b a) where
  mempty = W mempty 
mapW f (W l) = W $ map (\(a,b) -&gt; (a,f b)) l
instance Functor (W b) where
    fmap f (W a) = W $ map (\(a,p) -&gt; (f a,p)) a

instance Num b =&gt; Applicative (W b) where
  pure x = W [(x,1)]
  (W fs) &lt;*&gt; (W xs) = W [(f x, a * b) | (f, a) &lt;- fs, (x, b) &lt;- xs] 


instance Num b =&gt; Monad (W b) where
   return x = W [(x,1)]
   l &gt;&gt;= f = W $ concatMap (\(W d,p) -&gt; map (\(x,q)-&gt;(x,p*q)) d) (runW $ fmap f l)

a .* b = mapW (a*) b

instance (Eq a,Show a,Num b) =&gt; Num (W b a) where
     W a + W b = W $ (a ++ b)
     a - b = a + (-1) .* b
     _ * _ = error "Num is annoying"
     abs _ = error "Num is annoying"
     signum _ = error "Num is annoying"
     fromInteger a = if a==0 then W [] else error "fromInteger can only take zero argument"

collect :: (Ord a,Num b) =&gt; W b a -&gt; W b a
collect = W . Map.toList . Map.fromListWith (+) . runW

trimZero = W . filter (\(k,v) -&gt; not $ nearZero v) . runW
simplify = trimZero . collect
-- filter (not . nearZero . snd)

type P a = W Double a

type Q a = W (Complex Double) a
</code></pre></div></div>

<p>The Vector monad factors out the linear piece of a computation. Because of this factoring, the type constrains the mapping to be linear, in a similar way that monads in other contexts might guarantee no leaking of impure computations. This is pretty handy.¬†The function you give to bind correspond to a selector columns of the matrix.</p>

<p>We need some way to zoom into a subtrees and then apply operations. We define the operations lmap and rmap.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lmap :: (forall a. FibTree a b -&gt; Q (FibTree a c)) -&gt; (FibTree e (b,d) -&gt; Q (FibTree e (c,d)))
lmap f (ITT l r) = fmap (\l' -&gt; ITT l' r) (f l)
lmap f (TTI l r) = fmap (\l' -&gt; TTI l' r) (f l)
lmap f (TIT l r) = fmap (\l' -&gt; TIT l' r) (f l)
lmap f (TTT l r) = fmap (\l' -&gt; TTT l' r) (f l)
lmap f (III l r) = fmap (\l' -&gt; III l' r) (f l)


rmap :: (forall a. FibTree a b -&gt; Q (FibTree a c)) -&gt; (FibTree e (d,b) -&gt; Q (FibTree e (d,c)))
rmap f (ITT l r) = fmap (\r' -&gt; ITT l r') (f r)
rmap f (TTI l r) = fmap (\r' -&gt; TTI l r') (f r)
rmap f (TIT l r) = fmap (\r' -&gt; TIT l r') (f r)
rmap f (TTT l r) = fmap (\r' -&gt; TTT l r') (f r)
rmap f (III l r) = fmap (\r' -&gt; III l r') (f r)
</code></pre></div></div>

<p>You reference a node by the path it takes to get there from the root. For example,¬† <code class="language-plaintext highlighter-rouge">(rmap . lmap . rmap) f</code> applies f at the node that is at the right-left-right position down from the root.</p>

<h6 id="braiding">Braiding</h6>

<p>For Fibonacci anyons, the only two non trivial braidings happen when you braid two $latex \tau$ particles.¬†<a href="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/braid.jpg"><img src="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/braid.jpg" alt="" /></a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>braid :: FibTree a (l,r) -&gt; Q (FibTree a (r,l))
braid (ITT l r) = W [(ITT r l,  cis $ 4 * pi / 5)] 
braid (TTT l r) = W [(TTT r l,  (cis $ - 3 * pi / 5))]
braid (TTI l r) = pure $ TIT r l
braid (TIT l r) = pure $ TTI r l
braid (III l r) = pure $ III r l

-- The inverse of braid
braid' :: FibTree a (l,r) -&gt; Q (FibTree a (r,l))
braid' = star . braid
</code></pre></div></div>

<p>We only have defined how to braid two particles that were split directly from the same particle. How do we describe the braiding for the other cases? Well we need to give the linear transformation for how to change basis into other tree structures. Then we have defined braiding for particles without the same immediate parent also.</p>

<h6 id="f-moves">F-Moves</h6>

<p>We can transform to a new basis. where the histories differs by association. We can braid two particles by associating the tree until they are together. An association move does not change any of the outgoing leaf positions. It can, however, change a particle in an interior position. We can apply an F-move anywhere inside the tree, not only at the final leaves.<a href="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/243b7117-10e3-4211-866c-718ef9eabea9-5.png"><img src="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/243b7117-10e3-4211-866c-718ef9eabea9-5.png" alt="" /></a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmove :: FibTree a (c,(d,e)) -&gt; Q (FibTree a ((c,d),e))
fmove (ITT  a  (TIT b c)) = pure $ ITT ( TTI  a b) c
fmove (ITT  a  (TTT b c)) = pure $ ITT ( TTT  a b) c
fmove (ITT  a  (TTI b c)) = pure $ III ( ITT  a b) c

fmove (TIT  a  (TTT b c)) = pure $ TTT ( TIT  a b) c
fmove (TIT  a  (TTI b c)) = pure $ TTI ( TIT  a b) c
fmove (TIT  a  (TIT b c)) = pure $ TIT ( III  a b) c

fmove (TTI  a  (III b c)) = pure $ TTI ( TTI  a b) c
fmove (TTI  a  (ITT b c)) = W [(TIT ( ITT  a b) c, tau)         , (TTT ( TTT  a b) c, sqrt tau)]

fmove (TTT  a  (TTT b c)) = W [(TIT ( ITT  a b) c, sqrt tau)  ,   (TTT ( TTT  a b) c, - tau   )]
fmove (TTT  a  (TTI b c)) = pure $ TTI ( TTT  a b) c
fmove (TTT  a  (TIT b c)) = pure $ TTT ( TTI  a b) c 

fmove (III  a  (ITT b c)) = pure $ ITT ( TIT  a b) c
fmove (III  a  (III b c)) = pure $ III ( III  a b) c



fmove' :: FibTree a ((c,d),e) -&gt; Q (FibTree a (c,(d,e)))
fmove' (ITT ( TTI  a b) c) = pure $ (ITT  a  (TIT b c))
fmove' (ITT ( TTT  a b) c) = pure $  (ITT  a  (TTT b c))
fmove' (ITT ( TIT  a b) c) = pure $  (III  a  (ITT b c))



fmove' (TTI ( TTT  a b) c) = pure $ (TTT  a  (TTI b c))
fmove' (TTI ( TTI  a b) c) = pure $ (TTI  a  (III b c))
fmove' (TTI ( TIT  a b) c) = pure $ TIT  a  (TTI b c)

fmove' (TTT ( TTI  a b) c ) = pure $ TTT  a  (TIT b c)
fmove' (TTT ( TIT  a b) c ) = pure $ TIT  a  (TTT b c)
fmove' (TTT ( TTT  a b) c) = W [(TTI  a  (ITT b c), sqrt tau)  , (TTT  a  (TTT b c),   - tau  )]


fmove' (TIT ( ITT  a b) c) = W [(TTI  a  (ITT b c), tau)         , (TTT  a  (TTT b c) , sqrt tau)]
fmove' (TIT ( III  a b) c ) = pure $ TIT  a  (TIT b c)

fmove' (III ( III  a b) c ) = pure $ III  a  (III b c)
fmove' (III ( ITT  a b) c
</code></pre></div></div>

<h6 id="fusion--dot-product">Fusion / Dot product</h6>

<p>Two particles that split can only fuse back into themselves. So the definition is pretty trivial. This is like $latex \hat{e}<em>i \cdot \hat{e}_j = \delta</em>{ij}$.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dot :: FibTree a (b, c) -&gt; FibTree a' (b, c) -&gt; Q (FibTree a' a)
dot x@(TTI _ _) y@(TTI _ _) | x == y = pure TLeaf
                             | otherwise = mempty
dot x@(TIT _ _) y@(TIT _ _) | x == y = pure TLeaf
                             | otherwise = mempty
dot x@(TTT _ _) y@(TTT _ _) | x == y = pure TLeaf
                            | otherwise = mempty
dot x@(III _ _) y@(III _ _) | x == y = pure ILeaf
                            | otherwise = mempty
dot x@(ITT _ _) y@(ITT _ _) | x == y = pure ILeaf
                            | otherwise = mempty
dot _ _ = mempty
</code></pre></div></div>

<p><a href="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/243b7117-10e3-4211-866c-718ef9eabea9-3.png"><img src="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/243b7117-10e3-4211-866c-718ef9eabea9-3.png" alt="" /></a></p>

<p>######</p>

<h6 id="hexagon-and-pentagon-equations">Hexagon and Pentagon equations</h6>

<p>The F and R matrices and the fusion rules need to obey consistency conditions called the hexagon and pentagon equations. Certain simple rearrangements have alternate ways of being achieved. The alternative paths need to agree.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pentagon1 ::  FibTree a (e,(d,(c,b))) -&gt; Q (FibTree a (((e,d),c),b))
pentagon1 v =  do 
                 v1 &lt;- fmove v
                 fmove v1

pentagon2 :: FibTree a (b,(c,(d,e))) -&gt; Q (FibTree a (((b,c),d),e))
pentagon2 v = do
                v1 :: FibTree a (b,((c,d),e)) &lt;- rmap fmove v
                v2 :: FibTree a ((b,(c,d)),e) &lt;- fmove v1
                lmap fmove v2

ex1 = TTT TLeaf (TTT TLeaf (TTT TLeaf TLeaf))
-- returns empty
pentagon =  simplify $ ((pentagon1 ex1) - (pentagon2 ex1))

hexagon1 :: FibTree a (b,(c,d)) -&gt; Q (FibTree a ((d,b),c))
hexagon1 v = do
             v1 :: FibTree a ((b,c),d) &lt;- fmove v
             v2 :: FibTree a (d,(b,c)) &lt;- braid v1
             fmove v2  

hexagon2 :: FibTree a (b,(c,d)) -&gt; Q (FibTree a ((d,b),c))
hexagon2 v = do
             v1 :: FibTree a (b,(d,c)) &lt;- rmap braid v
             v2 :: FibTree a ((b,d),c) &lt;- fmove v1
             lmap braid v2


ex2 = (TTT TLeaf (TTT TLeaf TLeaf))
--returns empty
hexagon =  simplify $ ((hexagon1 ex2) - (hexagon2 ex2))
</code></pre></div></div>

<p><a href="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/hexagon.png"><img src="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/hexagon.png" alt="" /></a> <a href="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/pentagon.png"><img src="http://philzucker2.nfshost.com/wp-content/uploads/2018/11/pentagon.png" alt="" /></a></p>

<h6 id="next-time">Next Time:</h6>

<p>With this, we have the rudiments of what we need to describe manipulation of anyon spaces. However, applying F-moves manually is rather laborious. Next time we‚Äôll look into automating this using arcane type-level programming. You can take a peek at my trash WIP repo <a href="https://github.com/philzook58/fib-anyon">here</a></p>

<h6 id="references">RefErences:</h6>

<p>John Preskill‚Äôs notes:¬†<a href="http://www.theory.caltech.edu/~preskill/ph219/topological.pdf">www.theory.caltech.edu/~preskill/ph219/topological.pdf</a></p>

<p>A big ole review on topological quantum computation:¬†<a href="https://arxiv.org/abs/0707.1889">https://arxiv.org/abs/0707.1889</a></p>

<p>Ady Stern on The fractional quantum hall effect and anyons:¬†<a href="https://www.sciencedirect.com/science/article/pii/S0003491607001674">https://www.sciencedirect.com/science/article/pii/S0003491607001674</a></p>

<p>Another good anyon tutorial:¬†<a href="https://arxiv.org/abs/0902.3275">https://arxiv.org/abs/0902.3275</a></p>

<p>Mathematica program that I still don‚Äôt get, but is very interesting:¬†<a href="http://www.cs.ox.ac.uk/people/jamie.vicary/twovect/guide.pdf">http://www.cs.ox.ac.uk/people/jamie.vicary/twovect/guide.pdf</a></p>

<p>Kitaev huge Paper:¬†<a href="https://arxiv.org/abs/cond-mat/0506438">https://arxiv.org/abs/cond-mat/0506438</a></p>

<p>Bonderson thesis:¬†<a href="https://thesis.library.caltech.edu/2447/2/thesis.pdf">https://thesis.library.caltech.edu/2447/2/thesis.pdf</a></p>

<p>Bernevig review:¬†<a href="https://arxiv.org/abs/1506.05805">https://arxiv.org/abs/1506.05805</a></p>

<p>More food for thought:</p>

<p>The Rosetta Stone:¬†<a href="http://math.ucr.edu/home/baez/rosetta.pdf">http://math.ucr.edu/home/baez/rosetta.pdf</a></p>

<p><a href="http://blog.sigfpe.com/2008/08/hopf-algebra-group-monad.html">http://blog.sigfpe.com/2008/08/hopf-algebra-group-monad.html</a></p>

<p><a href="http://haskellformaths.blogspot.com/2012/03/what-is-hopf-algebra.html">http://haskellformaths.blogspot.com/2012/03/what-is-hopf-algebra.html</a></p>

<p>https://vimeo.com/6590617</p>

:ET
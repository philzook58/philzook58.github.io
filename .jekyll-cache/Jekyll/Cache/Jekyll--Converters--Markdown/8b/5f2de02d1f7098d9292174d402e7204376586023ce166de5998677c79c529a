I"úV<p>I know a bit of Haskell. It‚Äôs the functional programming language I have the strongest background in. OCaml is very similar to Haskell, which is why I haven‚Äôt felt a strong need to learn it. Having had to delve into it for necessity because of work I think that was an oversight. The biggest thing for me is being able to more easily read a new set of literature and see familiar things in a new light, which is very refreshing.</p>

<h3 id="getting-ocaml">Getting OCaml</h3>

<p><a href="https://ocaml.org/docs/install.html">https://ocaml.org/docs/install.html</a></p>

<p>opam is the package manager. Follow the instructions to install it and get your environment variables setup. It‚Äôll tell you some extra commands you have to run to do so. You use it to install packages via <code class="language-plaintext highlighter-rouge">opam install packagename</code>. You can also use it to switch between different ocaml compiler versions via command like <code class="language-plaintext highlighter-rouge">opam switch 4.08.1</code>.</p>

<p>Dune is a build tool. You can place a small config file called <code class="language-plaintext highlighter-rouge">dune</code> in your  folder and it can figure out how to appropriately call the compiler. Dune is in flux, so check out the documentation. What I write here may be wrong.</p>

<p><a href="https://dune.readthedocs.io/en/stable/">https://dune.readthedocs.io/en/stable/</a></p>

<p>Here‚Äôs an example execution. Note that even though the file is called <code class="language-plaintext highlighter-rouge">main.ml</code> in this example, you call build with <code class="language-plaintext highlighter-rouge">main.exe</code>. And exec requires the <code class="language-plaintext highlighter-rouge">./</code> for some reason. Weird.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;dune init exe hello
dune exec ./main.exe
dune build main.exe
&lt;/code&gt;
</code></pre></div></div>

<p>Here‚Äôs a dune file with some junk in it. You make executables with blocks. You include a list of the files without the .ml suffix require by the executable in the modules line. You list libraries needed in the libraries line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;(executable
 (name main)
 (modules ("main"))
 (libraries core z3 owl owl-plplot)
 )

 (executable 
  (name lambda)
  (modules ("lambda"))
  (libraries core)
 )&lt;/code&gt;
</code></pre></div></div>

<p>You want to also install merlin. <code class="language-plaintext highlighter-rouge">opam install merlin</code>. Merlin is a very slick IDE tool with autocomplete and type information.  dune will setup a .merlin file for you</p>

<p>The ReasonML plugin is good for vscode. Search for it on the marketplace. It is the one for OCaml also. ReasonML is a syntactic facelift intended for the web btw. I don‚Äôt particularly recommend it to start. There are also emacs and vim modes if that is what you‚Äôre into.</p>

<p>The enhanced repl is called utop. Install it with <code class="language-plaintext highlighter-rouge">opam install utop</code>. Basic repl usage: Every line has to end with <code class="language-plaintext highlighter-rouge">;;</code>.  That‚Äôs how you get stuff to be run. Commands start with <code class="language-plaintext highlighter-rouge">#</code>. For example <code class="language-plaintext highlighter-rouge">#quit;;</code> is how you end the session. <code class="language-plaintext highlighter-rouge">#use "myfile.ml";;</code> will load a file you‚Äôve made. Sometimes when you start you need to run <code class="language-plaintext highlighter-rouge">#use "topfind";;</code> which loads a package finder. You can load libraries via the require command like <code class="language-plaintext highlighter-rouge">#require "Core";;</code></p>

<p><code class="language-plaintext highlighter-rouge">#help;;</code> for more.</p>

<h3 id="a-quick-look-at-the-language">A Quick Look at the Language</h3>

<p>With any new language I like to check out Learn X from Y if one is available.</p>

<p><a href="https://learnxinyminutes.com/docs/ocaml/">https://learnxinyminutes.com/docs/ocaml/</a></p>

<p>Here are some shortish cheat sheets with a quick overview of syntax</p>

<p><a href="https://github.com/alhassy/OCamlCheatSheet">https://github.com/alhassy/OCamlCheatSheet</a></p>

<p><a href="https://ocaml.org/docs/cheat_sheets.html">https://ocaml.org/docs/cheat_sheets.html</a></p>

<h3 id="more-in-depth-looks">More In Depth Looks</h3>

<p>This is a phenomenal book online book built for a Cornell course: <a href="https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/">https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/</a></p>

<p><a href="http://dev.realworldocaml.org/">Real World OCaml</a> is also quite good but denser. Very useful as a reference for usage of Core and other important libraries.</p>

<p>The reference manual is also surprisingly readable <a href="https://caml.inria.fr/pub/docs/manual-ocaml/">https://caml.inria.fr/pub/docs/manual-ocaml/</a> . The first 100 or so pages are a straightforward introduction to the language.</p>

<p><a href="https://github.com/janestreet/learn-ocaml-workshop">https://github.com/janestreet/learn-ocaml-workshop</a> Pretty basic workshop. Could be useful getting you up and running though.</p>

<h3 id="useful-libraries">Useful libraries</h3>

<p>Core - a standard library replacement. Becoming increasingly common <a href="https://github.com/janestreet/core">https://github.com/janestreet/core</a> It is quite a bit more confusing for a newcomer than the standard library IMO. And the way they have formatted their docs is awful.</p>

<p>Owl - a numerical library. Similar to Numpy in many ways. <a href="https://ocaml.xyz/">https://ocaml.xyz/</a> These tutorials are clutch <a href="https://github.com/owlbarn/owl/wiki">https://github.com/owlbarn/owl/wiki</a></p>

<p><a href="https://github.com/BinaryAnalysisPlatform/bap">Bap -</a> Binary Analysis Platform. Neato stuff</p>

<p>Lwt - <a href="https://github.com/ocsigen/lwt">https://github.com/ocsigen/lwt</a> asynchronous programming</p>

<p>Graphics - gives you some toy and not toy stuff. Lets you draw lines and circles and get keyboard events in a simple way.</p>

<p>OCamlGraph - a graph library</p>

<p><a href="https://github.com/akabe/ocaml-jupyter">Jupyter Notebook</a> - Kind of neat. I‚Äôve got one working on binder. Check it out here. <a href="https://github.com/philzook58/ocaml_binder">https://github.com/philzook58/ocaml_binder</a></p>

<p>Menhir and OCamlLex. Useful for lexer and parser generators. Check out the ocaml book for more</p>

<p>fmt -  for pretty printing</p>

<h3 id="interesting-other-stuff-a-descent-into-lazy-writing">Interesting Other Stuff (A Descent into Lazy Writing)</h3>

<p><a href="https://discuss.ocaml.org/">https://discuss.ocaml.org/</a> - The discourse. Friendly people. They don‚Äôt bite. Ask questions.</p>

<p><a href="https://github.com/ocaml-community/awesome-ocaml">https://github.com/ocaml-community/awesome-ocaml</a> Awesome-Ocaml list. A huge dump of interesting libraries and resources.</p>

<p>An excerpt of cool stuff:</p>

<ul>
  <li><a href="https://coq.inria.fr/">Coq</a> ‚Äì Coq is a formal proof management system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs.</li>
  <li><a href="http://why3.lri.fr/">Why3</a> ‚Äì Why3 is a platform for deductive program verification. It provides a rich language for specification and programming, called WhyML, and relies on external theorem provers, both automated and interactive, to discharge verification conditions.</li>
  <li><a href="http://alt-ergo.lri.fr/">Alt-Ergo</a> ‚Äì Alt-Ergo is an open-source SMT solver dedicated to the proof of mathematical formulas generated in the context of program verification.</li>
</ul>

<p><a href="http://ocamlverse.github.io/">http://ocamlverse.github.io/</a> - A pretty good set of beginner advice and articles. Seems like I have a lot of accidental overlap. Would‚Äôve been nice to find earlier</p>

<p><a href="https://www.cl.cam.ac.uk/teaching/1617/L28/materials.html">https://www.cl.cam.ac.uk/teaching/1617/L28/materials.html</a> - advanced functional programming course. Interesting material.</p>

<p>TAPL - <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">https://www.cis.upenn.edu/~bcpierce/tapl/</a> Has implementations in OCaml of different lambda calculi. Good book too.</p>

<p>It is not uncommon to use a preprocessor in OCaml for some useful features. There is monad syntax, list comprehensions, deriving and more available as ppx extensions.</p>

<p><a href="https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/">https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/</a> ppx perepsorcssor. ocamlp4 5 are both preprocessors too</p>

<p><a href="https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem.html">https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem.html</a></p>

<p><a href="https://blog.janestreet.com/archive/">https://blog.janestreet.com/archive/</a> The jane street blog. They are very prominent users of ocaml.</p>

<p><a href="https://opensource.janestreet.com/standards/">https://opensource.janestreet.com/standards/</a> Jane Street style guide</p>

<p>https://youtu.be/QDXfKXi_Q_A</p>

<p>Oleg Kiselyov half works in Haskell, half in OCaml, so that‚Äôs cool.</p>

<p><a href="https://arxiv.org/pdf/1905.06544.pdf">https://arxiv.org/pdf/1905.06544.pdf</a> oleg effects without monads</p>

<p>Oleg metaocaml book. MetaOCaml is super cool. <a href="http://okmij.org/ftp/ML/MetaOCaml.html">http://okmij.org/ftp/ML/MetaOCaml.html</a> And the switch funtionality of opam makes it easy to install!</p>

<p>Oleg tagless final <a href="http://okmij.org/ftp/tagless-final/index.html">http://okmij.org/ftp/tagless-final/index.html</a></p>

<p><a href="https://github.com/ocamllabs/higher">https://github.com/ocamllabs/higher</a></p>

<p>Cohttp, LWT and Async</p>

<p><a href="https://github.com/backtracking/ocamlgraph">https://github.com/backtracking/ocamlgraph</a> ocaml graphs</p>

<p><a href="https://mirage.io/">https://mirage.io/</a> Mirage os. What the hell is this?</p>

<p><a href="https://github.com/ocamllabs/fomega">https://github.com/ocamllabs/fomega</a></p>

<p><a href="https://github.com/janestreet/hardcaml">https://github.com/janestreet/hardcaml</a></p>

<p>ppx_let monaidc let bindings</p>

<p>some of the awesome derivinig capabilites are given by ppx_jane. SExp seems to be a realy good one. It‚Äôs where generic printing is?</p>

<p><code class="language-plaintext highlighter-rouge">dune build lambda.bc.js</code> will make a javascript file. That‚Äôs pretty cool. Uses js_of_ocaml. The js_of_ocaml docs are intimidating  <a href="https://ocsigen.org/js_of_ocaml/dev/manual/overview">https://ocsigen.org/js_of_ocaml/dev/manual/overview</a></p>

<p><a href="http://ocsigen.org/js_of_ocaml/dev/api/">http://ocsigen.org/js_of_ocaml/dev/api/</a></p>

<p>Note you need to install both the js_of_ocaml-compiler AND the library js_of_ocaml and also the js_of_ocaml-ppx.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;(executable
 (name jsboy)
 (libraries js_of_ocaml)
 (preprocess (pps js_of_ocaml-ppx))
 )&lt;/code&gt;







&lt;code&gt;open Js_of_ocaml
let _ =
  Js.export "myMathLib"
    (object%js
       method add x y = x +. y
       method abs x = abs_float x
       val zero = 0.
     end)&lt;/code&gt;
</code></pre></div></div>

<p>Go digging through your _build folder and you can find a completely mangled incomprehensible file <code class="language-plaintext highlighter-rouge">jsboy.bc.js</code>. But you can indeed import and use it like so.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;var mystuff = require("./jsboy.bc.js").myMathLib;
console.log(mystuff)
console.log(mystuff.add(1,2))&lt;/code&gt;







&lt;code&gt;node test.js&lt;/code&gt;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">dune build --profile release lambda.bc.js</code> putting it in the release profile makes an insane difference in build size. 10mb -&gt; 100kb</p>

<p>There is also bucklescript for compiling to javascript. Outputs readable javascript. Old compiler fork?</p>

<p>Check out J.T. Paach‚Äôs snippets. Helpful</p>

<p>Dune:</p>

<p><a href="https://gist.github.com/jtpaasch/ce364f62e283d654f8316922ceeb96db">https://gist.github.com/jtpaasch/ce364f62e283d654f8316922ceeb96db</a></p>

<p>Z3 ocaml</p>

<p><a href="https://gist.github.com/jtpaasch/3a93a9e1bcf9cae86e9e7f7d3484734b">https://gist.github.com/jtpaasch/3a93a9e1bcf9cae86e9e7f7d3484734b</a></p>

<p>Ocaml new monadic let syntax</p>

<p><a href="https://jobjo.github.io/2019/04/24/ocaml-has-some-new-shiny-syntax.html">https://jobjo.github.io/2019/04/24/ocaml-has-some-new-shiny-syntax.html</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;&lt;/code&gt;
</code></pre></div></div>

<p>#require ‚Äúppx_jane‚Äù;; in utop in order to import a thing using ppx</p>

<p>And argument could be made for working from a docker</p>

<p>Weird dsls that generate parsers and lexers. Also oddly stateful.</p>

<p>Took a bit of fiddling to figure out how to get dune to do.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt; (executable
 (name lisp)
 (modules ("lisp" "parse_lisp" "lex_lisp" "ast"))
 (preprocess (pps  ppx_jane))
 (libraries core)
 )

(ocamllex
  (modules lex_lisp))

(menhir
 
 (modules parse_lisp))&lt;/code&gt;
</code></pre></div></div>

<p>Otherwise pretty straight forward encoding</p>

<p>expereince rport: using f omega as a teaching language</p>

<p>Because they aren‚Äôt hidden behind a monadic interface (for better or for worse), OCaml has a lot more of imperative feel. You could program in a subset of the language and have it not feel all that different from Java or python or something. There are for loops and while loops, objects and classes, and mutable variables if you so choose. I feel like the community is trying to shy away from these features for most purposes however, sitcking to the functional core.</p>

<p>However, it does let you do for loops and has an interesting community anddifferent areas of strength.</p>

<p>Maybe more importantly it let‚Äôs you access a new set of literature and books. Sligthly different but familiar ideas</p>

<p>I think Core is bewildering for a newcomer.</p>

<h3 id="rando-trash-poor-style-ocaml-snippets">Rando Trash Poor Style OCaml Snippets</h3>

<p>lex_lisp.mll : simplistic usage of ocamllex and menhir</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;{
  (*
type token = RightParen | LeftParen | Id of string
*)

open Lexing
open Parse_lisp

exception SyntaxError of string

let next_line lexbuf =
  let pos = lexbuf.lex_curr_p in
  lexbuf.lex_curr_p &lt;-
    { pos with pos_bol = lexbuf.lex_curr_pos;
               pos_lnum = pos.pos_lnum + 1
    }
}


let white = [' ' '\t']+
let newline = '\r' | '\n' | "\r\n"
let id = ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*

rule read =
  parse
  | white    { read lexbuf }
  | newline  { next_line lexbuf; read lexbuf }
  | '('      { LEFTPAREN }
  | ')'    { RIGHTPAREN }
  | id     {  ID( Lexing.lexeme lexbuf )  }
  | eof     {  EOF }&lt;/code&gt;
</code></pre></div></div>

<p>parse_lisp.mly</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;%token &lt;string&gt; ID
%token RIGHTPAREN
%token LEFTPAREN
%token EOF



%start &lt;Ast.tree list&gt; prog
%%



prog:
  | s = sexpr; p = prog              { s :: p }
  | EOF                      {[]}


sexpr : 
  | LEFTPAREN;  l = idlist; RIGHTPAREN { Ast.Node( l ) }
  | s = ID                         { Ast.Atom(s) } 

(* inefficient because right recursive 
There are thingy's in menhir to ake this better?
*)
idlist :
  | (* empty *) { [] }
  | x = sexpr; l = idlist { x :: l  } 



(* *)&lt;/code&gt;
</code></pre></div></div>

<p>Doinking around with some graphics</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;
open Core
(* Printf.printf "%b\n" status.keypressed *)
let loop : Graphics.status -&gt; unit = fun _ -&gt; Graphics.draw_circle 200 200 50;
                                              Graphics.fill_rect 400 400 50 50



                                              (* Graphics.synchronize () *)
      
                                    

let main () = Graphics.open_graph ""; 
              Graphics.set_window_title "My Fun Boy";
              (* Graphics.auto_synchronize true; *)
              Graphics.set_color Graphics.black;
              Graphics.draw_circle 200 200 50;
              List.iter ~f:(fun i -&gt; Graphics.fill_circle (200 + 20 * i) 200 50) [1;2;3;4];
              (* Graphics.sound 500 5000; *)
              let img = Images.load "fish.jpg" [] in 
              
              (* Images. *)
              Images.save "notfish.jpg" (Some Images.Jpeg) [] img;
              Graphic_image.draw_image img 0 0;
              Graphics.loop_at_exit [Graphics.Poll;Graphics.Key_pressed] loop
              (* 
              let evt = Graphics.wait_next_event [Graphics.Key_pressed] in
              () *)



(* let i = create_image 640 640 *)
(** resize_window  640 640 *)

              


let () = main ()&lt;/code&gt;
</code></pre></div></div>

<p>A couple Advent of code 2018</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;open Core_kernel

(** if I want to try pulling input from the web *)
(**  https://adventofcode.com/2018/day/1/input *)

let r = In_channel.read_lines "puzz.txt"


let main () = Printf.printf "Hey\n";
              let puzz = In_channel.read_lines "puzz.txt" |&gt;  List.map ~f:int_of_string  in
              (* List.iter puzz ~f:(fun x -&gt; Printf.printf "%d " x); *)
              let res = List.fold puzz ~init:0 ~f:(+) in
              Printf.printf "Sum: %d\n" res


             
let () = main ()&lt;/code&gt;







&lt;code&gt;open Core_kernel

(**   
Obviously the way I'm doing it is not that efficient, nor all that clean really.

*)
(*
let exists23 str = let charset = String.to_list str |&gt; Set.of_list (module Char) |&gt; Set.to_list in
                  let counts = List.map ~f:(fun c -&gt; String.count str ~f:(fun y -&gt; y = c)) charset in
                  (List.exists counts ~f:(fun i -&gt; i = 3), List.exists counts ~f:(fun i -&gt; i = 2)) 
*)

let exists23 str = let charset = String.to_list str |&gt; Set.of_list (module Char) in
                   let counts = Set.map (module Int) ~f:(fun c -&gt; String.count str ~f:((=) c)) charset in
                   (Set.mem counts 2, Set.mem counts 3) 

let main () = Printf.printf "Hey\n";
              let puzz = In_channel.read_lines "puzz2.txt" in
              let res = List.map ~f:exists23 puzz in
              let (c2,c3) = List.fold res ~init:(0,0) ~f:(fun (x,y) (a,b) -&gt; (begin if a then (x + 1) else x end, begin if b then y + 1 else y end)) in
              Printf.printf "Prod: %d\n" (c2 * c3)


             
let () = main ()&lt;/code&gt;
</code></pre></div></div>

<p>A little Owl usage</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;open Core_kernel
open Owl

module Plot = Owl_plplot.Plot
let () = print_endline "Hello, World!"
let greeting name = Printf.printf "Hello, %s%i \n%!" name 7
(* let x : int = 7 *)

let () = greeting "fred"
(*
let () = match (In_channel.input_line In_channel.stdin) with
 | None -&gt; ()
 | Some x -&gt; print_endline x

let () = In_channel.with_file "dune" ~f:(fun t -&gt; 
    match In_channel.input_line t with
    | Some x -&gt; print_endline x
    | None -&gt; ()
)
*)
(**
type 'a mygadt = 
| Myint : int mygadt
| Mybool : bool mygadt
 *)
 
let kmat i j = if i = j then -2.0 
               else if abs (i - j) = 1 then 1.0 
               else 0.0
                 

let main () = 
    Mat.print (Mat.vector 10);
    Mat.print (Mat.uniform 5 5);
    Mat.print (Mat.zeros 5 5);
    let h = Owl_plplot.Plot.create "plot_003.png" in
    Plot.set_foreground_color h 0 0 0;
    Plot.set_background_color h 255 255 255;
    Plot.set_title h "Function: f(x) = sine x / x";
    Plot.set_xlabel h "x-axis";
    Plot.set_ylabel h "y-axis";
    Plot.set_font_size h 8.;
    Plot.set_pen_size h 3.;
    (* Plot.plot_fun ~h f 1. 15.; *)
    
    let x = Mat.linspace 0.0 1.0 20 in
    (*let f x = Maths.sin x /. x in
    Plot.plot_fun ~h f 1. 15.; *)
    let y = (Mat.ones 1 20) in
    Mat.print (Mat.ones 1 20);
    Mat.print (Mat.ones 10 1);
    Mat.print y;
    Mat.print x;
    (* y.{0,10} &lt;- 0.0; *)
    (* Mat.set y 10 1 0.0; *)
    Plot.plot ~h x (Mat.vector_ones 20);
    (* Owl_plplot.Plot.plot ~h x (Mat.vector_ones 20); *)
    Owl_plplot.Plot.output h;
    (* let q = Arr.create [|2;2;2|] 1.8 in *)
    let k = Mat.init_2d 10 10 kmat in 
    Mat.print k;
    Linalg.D.inv k |&gt; Mat.print;
    Plot.plot ~h x (Mat.row (Linalg.D.inv k) 5);
    Plot.plot ~h x (Mat.row (Linalg.D.inv k) 7);
    let r = Mat.zeros 1 10 in
    Mat.set r 0 0 (-2.0);
    Mat.set r 0 1 (1.0);
    let k2 = Mat.kron k k in
    let g2 = Linalg.D.inv k2 in
    let s = Mat.row g2 10 in
    let phi = Mat.reshape s [|10;10|] in 
    Plot.plot ~h x (Mat.row  phi 7); (** not convinecd this is actually doing what I want *)

    let k' = Mat.toeplitz r in (* also works. more cryptic though *)
    Mat.print k'







let () = main ()&lt;/code&gt;
</code></pre></div></div>

:ET
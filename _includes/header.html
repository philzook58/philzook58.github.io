<header class="site-header" style="background-color:#2e2256;">

  <div class="wrapper">
    {%- assign default_paths = site.pages | map: "path" -%}
    {%- assign page_paths = site.header_pages | default: default_paths -%}
    {%- assign titles_size = site.pages | map: 'title' | join: '' | size -%}

    <a class="site-title" style="color:#ffffff;" rel="author" href="{{ "/" | relative_url }}">{{ site.title | escape
      }}</a>

    {%- if titles_size > 0 -%}

    <nav class="site-nav" style="background-color:#2e2256; border-color:#2e2256">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" fill="#ffffff" width="18px" height="15px">
            <path fill="#ffffff"
              d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger">
        {%- for path in page_paths -%}
        {%- assign my_page = site.pages | where: "path", path | first -%}
        {%- if my_page.title -%}
        <a class="page-link" style="color:#ffffff;" href="{{ my_page.url | relative_url }}">{{ my_page.title | escape
          }}</a>
        {%- endif -%}
        {%- endfor -%}
      </div>


    </nav>
    {%- endif -%}
  </div>
  {% if page.layout == "post" %}
    {% assign fallback_author = page.author | default: site.author.name | default: site.author | default: site.github_username | default: site.twitter_username | default: site.title %}
    {% assign bib_key_source = page.bibtex_key | default: page.slug | default: page.url %}
    {% assign bib_key = bib_key_source | slugify %}
    {% assign bib_year = page.date | date: "%Y" %}
    {% assign bib_month = page.date | date: "%m" %}
    {% assign bib_day = page.date | date: "%d" %}
    {% assign bib_note = page.bibtex_note | default: page.description | default: site.tagline | default: site.title %}
    {% assign bib_type = page.bibtex_type | default: "online" %}
    <script>
      (function() {
        const bibMeta = {{ {
          type: bib_type,
          key: bib_key,
          title: page.title,
          author: "#{fallback_author}",
          year: bib_year,
          month: bib_month,
          day: bib_day,
          url: page.url | absolute_url,
          note: bib_note
        } | jsonify }};

        const normalize = function(value) {
          if (value === null || value === undefined) return "";
          return String(value).replace(/\s+/g, " ").replace(/([{}\\])/g, "\\$1").trim();
        };
        const buildBibtex = function() {
          const type = bibMeta.type || "online";
          const key = bibMeta.key || "post";
          const fields = [];
          const addField = function(name, value) {
            const normalized = normalize(value);
            if (!normalized) return;
            fields.push("  " + name + " = {" + normalized + "}");
          };
          addField("title", bibMeta.title);
          addField("author", bibMeta.author);
          addField("year", bibMeta.year);
          if (bibMeta.month && bibMeta.month !== "00") addField("month", bibMeta.month);
          if (bibMeta.day && bibMeta.day !== "00") addField("day", bibMeta.day);
          addField("url", bibMeta.url);
          addField("note", bibMeta.note);
          if (!fields.length) return "";
          return "@" + type + "{" + key + ",\n" + fields.join(",\n") + "\n}";
        };
        const copyText = function(text) {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            return navigator.clipboard.writeText(text);
          }
          return new Promise(function(resolve, reject) {
            const textarea = document.createElement("textarea");
            textarea.value = text;
            textarea.setAttribute("readonly", "");
            textarea.style.position = "absolute";
            textarea.style.left = "-9999px";
            document.body.appendChild(textarea);
            textarea.select();
            textarea.setSelectionRange(0, text.length);
            const success = document.execCommand("copy");
            document.body.removeChild(textarea);
            success ? resolve() : reject();
          });
        };
        const setStatus = (function() {
          let timer;
          return function(message, isError) {
            const statusEl = document.querySelector(".cite-status");
            const button = document.querySelector(".cite-button");
            if (!statusEl || !button) return;
            if (timer) clearTimeout(timer);
            statusEl.textContent = message || "";
            statusEl.dataset.error = isError ? "true" : "false";
            button.classList.toggle("copied", !!message && !isError);
            if (message) {
              timer = setTimeout(function() {
                statusEl.textContent = "";
                statusEl.dataset.error = "false";
                button.classList.remove("copied");
              }, 2200);
            }
          };
        })();

        document.addEventListener("DOMContentLoaded", function() {
          const meta = document.querySelector(".post-header .post-meta");
          if (!meta) return;
          const button = document.createElement("button");
          button.setAttribute("type", "button");
          button.className = "cite-button";
          button.textContent = "cite";
          const status = document.createElement("span");
          status.className = "cite-status";
          status.setAttribute("aria-live", "polite");
          status.dataset.error = "false";
          meta.appendChild(button);
          meta.appendChild(status);

          button.addEventListener("click", function() {
            const bibtex = buildBibtex();
            if (!bibtex) {
              setStatus("missing metadata", true);
              return;
            }
            copyText(bibtex).then(function() {
              setStatus("BibTeX copied");
            }, function() {
              setStatus("copy failed", true);
            });
          });
        });
      })();
    </script>
  {% endif %}
</header>
